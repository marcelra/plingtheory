#include "ScrollPaintArea.h"

#include <QBrush>
#include <QMouseEvent>
#include <QPainter>
#include <QPen>

namespace Plotting
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ScrollPaintArea::ScrollPaintArea( QWidget* parent ) :
   PaintAreaBase( parent ),
   m_dataMin( 0 ),
   m_dataMax( 0 ),
   m_isScrolling( false )
{}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// destructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ScrollPaintArea::~ScrollPaintArea()
{}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// setDataRange
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScrollPaintArea::setDataRange( double min, double max )
{
   m_dataMin = min;
   m_dataMax = max;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// paintEventImpl
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScrollPaintArea::paintEventImpl( QPaintEvent* paintEvent )
{
   assert( paintEvent );

   /// Draw background color.
   QColor bkgColor( Qt::lightGray );
   bkgColor.setRgb( 220, 220, 220 );
   QBrush brush( bkgColor, Qt::SolidPattern );
   getPainter().setBrush( brush );
   getPainter().setPen( QPen( brush, 0 ) );
   getPainter().drawRect( m_canvas );

   /// Draw data range.
   QColor dataRangeColor( bkgColor );
   dataRangeColor.setRgb( 180, 180, 180 );
   brush.setColor( dataRangeColor );
   getPainter().setPen( QPen( brush, 0 ) );
   getPainter().setBrush( brush );
   getPainter().drawRect( getDataRangeRect() );

   /// Draw scroll handle.
   QColor viewColor( Qt::blue );
   viewColor.setAlpha( 64 );
   brush.setColor( viewColor );
   getPainter().setBrush( brush );
   getPainter().setPen( QPen( brush, 2 ) );
   getPainter().drawRect( getViewRangeRect() );

}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// mouseMoveEvent
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScrollPaintArea::mouseMoveEvent( QMouseEvent* event )
{
   /// Store old mouse pos if it does not exist.
   if ( !m_oldMousePos.get() )
   {
      m_oldMousePos.reset( new QPoint( event->pos() ) );
      event->accept();
      return;
   }

   /// Notify that user is scrolling (this should freezes the viewport).
   setIsScrolling( true );

   /// Calculate shift in world coordinates.
   const QPointF& shiftOfViewport = transformToWorldCoordinates( event->pos() ) - transformToWorldCoordinates( *m_oldMousePos );

   /// Modify current viewport.
   updateViewportGraphFromShift( shiftOfViewport );

   /// Apply new viewport.
   emit viewportFromScroll( m_viewportGraph );

   /// Update mouse position.
   m_oldMousePos.reset( new QPoint( event->pos() ) );

   /// Notify that user has finished scrolling.
   setIsScrolling( false );

   /// Set event handled.
   event->accept();

   update();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// blockUpdateViewport
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScrollPaintArea::setIsScrolling( bool isScrolling )
{
   m_isScrolling = isScrolling;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// viewportUpdateIsBlocked
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool ScrollPaintArea::isScrolling() const
{
   return m_isScrolling;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// setViewport
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScrollPaintArea::setViewport( const QRectF& viewport )
{
   /// Only update the viewport of the graph when the user is scrolling.
   if ( isScrolling() )
   {
      m_viewportGraph = viewport;
   }
   else
   {
      m_viewport = viewport;
      m_viewportGraph = viewport;
      viewportGraphChanged( viewport );
   }
   update();
}

} /// namespace Plotting
