#include "McmcOptimiser.h"

#include "Logger.h"

/// TODO: used for heuristics in MLP learning
#include <cmath>

namespace Math
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
McmcOptimiser::McmcOptimiser( const IObjectiveFunction& objFunc ) :
   m_objFunc( objFunc ),
   m_numIterStepUpdate( 100 ),
   m_numIterations( 1000 ),
   m_burnInSkip( 200 ),
   m_stepMultiply( 1.0000001 ),
   m_effLow( 0.23 ),
   m_effHigh( 0.45 ),
   m_random( 10 )
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// setStartValues
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void McmcOptimiser::setStartValues( const RealVectorEnsemble& startValues )
{
   m_mcmcChains = startValues;
   m_probOld.resize( m_mcmcChains.size() );
   for ( size_t i = 0; i < m_mcmcChains.size(); ++i )
   {
      m_probOld[ i ] = calcProb( m_mcmcChains[ i ] );
   }
   m_numAccepted.assign( m_mcmcChains.size(), 0 );
   setStepSize( 1 );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// setStepSize
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void McmcOptimiser::setStepSize( double stepWidth )
{
   m_stepSizeVec.assign( m_mcmcChains.size(), stepWidth );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// setNumIterations
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void McmcOptimiser::setNumIterations( size_t numIterations )
{
   m_numIterations = numIterations;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// solve
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RealVectorEnsemble McmcOptimiser::solve()
{
   RealVectorEnsemble solutions;
   for ( size_t iIter = 0; iIter < m_numIterations; ++iIter )
   {
      for ( size_t iChain = 0; iChain < m_mcmcChains.size(); ++iChain )
      {
         const RealVector& x = proposeNew( m_mcmcChains[ iChain ], m_stepSizeVec[ iChain ] );

         double probNew = calcProb( x );
         if ( accept( probNew, m_probOld[ iChain ] ) )
         {
            m_mcmcChains[ iChain ] = x;
            m_probOld[ iChain ] = probNew;
            m_numAccepted[ iChain ] += 1;
         }
         if ( iIter > m_burnInSkip )
         {
            solutions.push_back( m_mcmcChains[ iChain ] );
         }
      }
      if ( ( iIter % m_numIterStepUpdate ) == 0 )
      {
         updateStepSize();
      }
   }
   return solutions;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// proposeNew
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RealVector McmcOptimiser::proposeNew( const RealVector& x, double stepSize )
{
   RealVector result( x );
   for ( size_t i = 0; i < x.size(); ++i )
   {
      result[ i ] += stepSize * m_random.uniform( -1, 1 ) * stepSize;
   }
   return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// calcProb
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double McmcOptimiser::calcProb( const RealVector& x )
{
   return m_objFunc.evaluate( x );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// accept
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool McmcOptimiser::accept( double probNew, double probOld )
{
   if ( probNew > probOld )
   {
      return true;
   }
   else
   {
      bool doAccept;
      if ( probOld < 0 )
      {
         /// TODO: heuristics for MLP learning
         // doAccept = m_random.uniform( probOld, 0 ) > probOld;
         doAccept = false;
      }
      else
      {
         doAccept = m_random.uniform( 0, probOld ) < probNew;
      }
      return doAccept;
   }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// updateStepSize
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void McmcOptimiser::updateStepSize()
{
   Logger msg( "McmcOptimiser" );
   for ( size_t i = 0; i < m_stepSizeVec.size(); ++i )
   {
      double eff = static_cast< double >( m_numAccepted[ i ] ) / m_numIterStepUpdate;
      msg << Msg::Info << "eff = " << m_numAccepted[ i ] << Msg::EndReq;
      if ( eff < m_effLow )
      {
         m_stepSizeVec[ i ] *= 0.9;
         // msg << Msg::Info << "---" << i << ": " << m_stepSizeVec[ i ] << Msg::EndReq;
      }
      else if ( eff > m_effHigh )
      {
         m_stepSizeVec[ i ] *= 1.1;
         // msg << Msg::Info << "+++" << i << ": " << m_stepSizeVec[ i ] << Msg::EndReq;
      }
      m_numAccepted[ i ] = 0;
   }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// setBurninSkip
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void McmcOptimiser::setBurninSkip( size_t numIterations )
{
   m_burnInSkip = numIterations;
}

} /// namespace Math
