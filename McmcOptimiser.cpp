#include "McmcOptimiser.h"

#include "Logger.h"

namespace Math
{

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
McmcOptimiser::McmcOptimiser( const IObjectiveFunction& objFunc ) :
   m_objFunc( objFunc ),
   m_numIterStepUpdate( 100 ),
   m_numIterations( 1000 ),
   m_burnInSkip( 200 ),
   m_numSamples( 1000 ),
   m_stepIncrease( 1.1 ),
   m_stepDecrease( 0.9 ),
   m_effLow( 0.23 ),
   m_effHigh( 0.45 ),
   m_random( 10 )
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// setStartValues
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void McmcOptimiser::setStartValues( const RealVectorEnsemble& startValues )
{
   m_mcmcChains = startValues;
   m_probOld.resize( m_mcmcChains.size() );
   for ( size_t i = 0; i < m_mcmcChains.size(); ++i )
   {
      m_probOld[ i ] = m_objFunc.evaluate( m_mcmcChains[ i ] );
   }
   m_numAccepted.assign( m_mcmcChains.size(), 0 );
   setStepSize( 1 );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// setStepSize
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void McmcOptimiser::setStepSize( double stepWidth )
{
   m_stepSizeVec.assign( m_mcmcChains.size(), stepWidth );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// setNumIterations
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void McmcOptimiser::setNumIterations( size_t numIterations )
{
   m_numIterations = numIterations;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// solve
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RealVectorEnsemble McmcOptimiser::solve()
{
   RealVectorEnsemble solutions;
   for ( size_t iIter = 0; iIter < m_numIterations + m_burnInSkip; ++iIter )
   {
      for ( size_t iChain = 0; iChain < m_mcmcChains.size(); ++iChain )
      {
         const RealVector& x = proposeNew( m_mcmcChains[ iChain ], m_stepSizeVec[ iChain ] );

         double probNew = m_objFunc.evaluate( x );
         if ( accept( probNew, m_probOld[ iChain ] ) )
         {
            m_mcmcChains[ iChain ] = x;
            m_probOld[ iChain ] = probNew;
            m_numAccepted[ iChain ] += 1;
         }
         if ( iIter > m_burnInSkip )
         {
            solutions.push_back( m_mcmcChains[ iChain ] );
         }
      }
      if ( ( iIter % m_numIterStepUpdate ) == 0 )
      {
         updateStepSize();
      }
   }
   return solutions;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// proposeNew
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
RealVector McmcOptimiser::proposeNew( const RealVector& x, double stepSize )
{
   RealVector result( x );
   for ( size_t i = 0; i < x.size(); ++i )
   {
      result[ i ] += stepSize * m_random.uniform( -1, 1 ) * stepSize;
   }
   return result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// accept
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool McmcOptimiser::accept( double probNew, double probOld )
{
   if ( probNew > probOld )
   {
      return true;
   }
   else
   {
      return m_random.uniform( 0, probOld ) < probNew;
   }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// updateStepSize
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void McmcOptimiser::updateStepSize()
{
   for ( size_t i = 0; i < m_stepSizeVec.size(); ++i )
   {
      double eff = static_cast< double >( m_numAccepted[ i ] ) / m_numIterStepUpdate;
      if ( eff < m_effLow )
      {
         m_stepSizeVec[ i ] *= m_stepDecrease;
      }
      else if ( eff > m_effHigh )
      {
         m_stepSizeVec[ i ] *= m_stepIncrease;
      }
      m_numAccepted[ i ] = 0;
   }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// setBurninSkip
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void McmcOptimiser::setBurninSkip( size_t numIterations )
{
   m_burnInSkip = numIterations;
}

} /// namespace Math
