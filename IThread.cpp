#include "IThread.h"

#include <cassert>
#include <functional>

#include <boost/chrono.hpp>
#include <boost/thread.hpp>

#include "Logger.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IThread::IThread( const std::string& threadName ) :
   m_isFinished( false ),
   m_isRunning( false ),
   m_pollTimeMilliSeconds( 1 ),
   m_logger( new Logger( threadName ) )
{}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// destructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IThread::~IThread()
{
   delete m_logger;
   if ( hasStarted() )
   {
      assert( isFinished() );
      assert( m_thread != 0 );
      delete m_thread;
   }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// getLogger
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Logger& IThread::getLogger()
{
   return *m_logger;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// start
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void IThread::start()
{
   assert( !hasStarted() );
   m_thread = new boost::thread( IThread::runWrapper, this );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// runWrapper
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void IThread::runWrapper( IThread* instance )
{
   instance->m_isRunning = true;
   instance->run();
   instance->m_isRunning = false;
   instance->m_isFinished = true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// join
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void IThread::join()
{
   getLogger() << Msg::Verbose << "In IThread::join..." << Msg::EndReq;
   size_t nPolls = 0;
   while ( !isFinished() )
   {
      ++nPolls;
      waitNextPoll();
   }
   getLogger() << Msg::Verbose << "Needed " << nPolls << " poll" << (nPolls != 1 ? "s" : "") <<
                  " of " << m_pollTimeMilliSeconds << " milliseconds before thread was finished." << Msg::EndReq;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// waitNextPoll
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void IThread::waitNextPoll()
{
   boost::this_thread::sleep_for( boost::chrono::milliseconds( m_pollTimeMilliSeconds ) );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// run
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void IThread::run()
{
   for ( size_t i = 0; i < 1000; ++i )
   {
      getLogger() << Msg::Verbose << "i = " << i << ": cos( i ) = " << cos( i ) << Msg::EndReq;
   }
}

