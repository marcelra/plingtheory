#ifndef REALMEMFUNCTION_H
#define REALMEMFUNCTION_H

#include "IRealFunction.h"

namespace Math
{

template < typename T >
class RealMemFunction : public IRealFunction
{
   public:
      RealMemFunction( double ( T::*memberFunc )( double ) const, const T* instance );

      double operator()( double x ) const;
      RealMemFunction* clone() const;

   private:
      double (T::*m_memberFunc )( double ) const;
      const T* m_instance;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// Implementation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// constructor
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template < typename T >
RealMemFunction< T >::RealMemFunction( double ( T::*memberFunc )( double ) const, const T* instance ) :
   m_memberFunc( memberFunc ),
   m_instance( instance )
{}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// operator()
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template < typename T >
inline double RealMemFunction< T >::operator()( double x ) const
{
   return ( m_instance->*m_memberFunc )( x );
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// clone
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template < typename T >
RealMemFunction< T >* RealMemFunction< T >::clone() const
{
   return new RealMemFunction< T >( *this );
}

} /// namespace Math

#endif // REALMEMFUNCTION_H
